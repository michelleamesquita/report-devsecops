-- MySQL dump 10.13  Distrib 8.0.31, for Linux (x86_64)
--
-- Host: 127.0.0.1    Database: sec
-- ------------------------------------------------------
-- Server version	5.7.39

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `report`
--
CREATE DATABASE sec;
use sec;

/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `report` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `vulnerability` varchar(5000) NOT NULL,
  `detail` varchar(5000) NOT NULL,
  `remediation` varchar(5000) NOT NULL,
  `reference` varchar(5000) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=53 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `report`
--

/*!40000 ALTER TABLE `report` DISABLE KEYS */;
INSERT INTO `report` VALUES (1,'Click vuln','---','---','---'),(4,'CONNECTION STRING INJECTION ','A vulnerabilidade String Injection ocorre quando a aplicação constrói dinamicamente uma conexão. Essa conexão pode ser alterada pelo atacante e injetar código malicioso no input, caso esse parâmetro não seja corretamente validado ou que os caracteres não escapem. Assim, um atacante poderia acessar um dado sensível ou mesmo, algum recurso do servidor, visto que seria onde essa aplicação estaria inicializada.     Na imagem da aba ao lado, temos um exemplo na variável XXX, identificada pela ferramenta Checkmarx, onde encontramos a vulnerabilidade descrita anteriormente.','A prevenção da vulnerabilidade Connection String Injection envolve alguns fatores: •	Evitar a construção dinâmica de conexões baseadas no uso de Strings nos inputs •	Permitir apenas que os usuários usem definições previamente definidas de conexões como uso de ENVs. •	Filtrar input utilizando Regex – para retornar exatamente o tipo de informação esperada pelo usuário. Por exemplo:  Assert.assertTrue(Pattern.matches(‘[a-zA-Z0-9\\\\s\\\\-]{1,50}’, userInput))    Dessa forma, aqui temos um exemplo de como criar uma conexão:  ConnectionStringBuilder connectionStringBuilder = new ConnectionStringBuilder()       .setNamespaceName(‘EventHubsNamespaceName’)       .setEventHubName(‘EventHubsEntityName’)       .setSasKeyName(‘SharedAccessSignatureKeyName’)       .setSasKey(‘SharedAccessSignatureKey’)    string connString = connectionStringBuilder.build();','https://www.geeksforgeeks.org/what-is-connection-string-parameter-pollution/'),(5,'XSS','O Cross-site scripting (XSS) é uma vulnerabilidade WEB que permite um atacante comprometer a interação do usuário com a aplicação. Dessa forma, essa vulnerabilidade ocorre quando um código JavaScript malicioso executa na aplicação, justamente pelo servidor da aplicação não possuir um mecanismo que trate esse código malicioso de ser inserido no input da aplicação. Existem alguns tipos de XSS: Refletido (Reflected), Armazenado (Stored) e DOM. O XSS armazenado, também conhecido como XSS persistente, é o mais prejudicial. Este ocorre quando um script malicioso é injetado diretamente em um aplicativo web vulnerável. O XSS refletido envolve a reflexão de um script malicioso de um aplicativo da web para o navegador de um usuário. O script é incorporado a um link e só é ativado quando esse link é clicado.   O XSS baseado em DOM é um ataque XSS em que a carga de ataque é executada como resultado da modificação do ‘ambiente’ DOM no navegador da vítima usado pelo lado do cliente original script, para que o código do lado do cliente seja executado de maneira ‘inesperada’. Um risco adicional com o DOM XSS é que, ao contrário do XSS refletido ou armazenado, os valores contaminados não têm que passar pelo servidor. Como o servidor não está envolvido na higienização dessas entradas, a validação do lado do servidor não deve estar ciente de que os ataques XSS estão ocorrendo, e quaisquer soluções de segurança do lado do servidor, como um WAF, provavelmente serão ineficazes na mitigação do DOM XSS.  Na imagem aba abaixo, temos um exemplo da variável XXXX, identificada pela ferramenta Checkmarx, onde encontramos a vulnerabilidade descrita anteriormente. Assim, durante o XSS refletido, o atacante pode inserir um código malicioso no input da aplicação ou em uma barra de busca, por exemplo. Dessa maneira, ele pode executar um código malicioso, como visto no exemplo abaixo, caso a aplicação não possua mecanismo de defesa:   https://insecure-website.com/status?message=<script>alert(1)</script> <script>alert(1)</script>','A prevenção da vulnerabilidade XSS envolve alguns fatores: •	Filtrar input utilizando Regex – para retornar exatamente o tipo de informação esperada pelo usuário. Por exemplo:  /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/  •	Utilizar encode no output  •	Setar o uso de HTTPOnly Flag na sessão do Cookie para prevenir da sessão ser roubada •	Utilização de Headers (cabeçalhos) essenciais na aplicação: - Content-Type - X-Content-Type-Options - Content Security Policy (CSP) - Anti-XSS  Dessa forma, podemos utilizar o encode HTML nas variáveis, como no exemplo anterior, na variável inscricaoMunicipal:  Encode.forHtml(matricula)  Em struts, por exemplo: <%@ taglib uri=‘http://java.sun.com/jsp/jstl/functions’prefix=‘fn’%> ${fn:escapeHtml(someValue)}  •	Em Javascript necessita criar uma função: function escapeHtml(unsafe) {     return unsafe          .replace(/&/g, ‘&amp;’)          .replace(/</g, ‘&lt;’)          .replace(/>/g, ‘&gt;’)          .replace(/’/g, ‘&quot;’)          .replace(/\'/g, ‘&#039;’);  }  Além disso, devemos adicionar no arquivo pom.xml : <dependency>  <groupId>org.springframework.security</groupId>  <artifactId>spring-security-core</artifactId>  </dependency>  Como também, no arquivo referente a parte de segurança, como por exemplo, webSecurity.java . Deve-se adicionar : @Configuration public class SecurityConf extends WebSecurityConfigurerAdapter {  @Override protected void configure(HttpSecurity http) throws Exception {         http           .headers()           .xssProtection()           .and()           .contentSecurityPolicy(‘script-src \'self\'‘) 	 .contentTypeOptions() 	 .httpStrictTransportSecurity()           .frameOptions();     } }','https://portswigger.net/kb/issues/00200300_cross-site-scripting-reflected'),(6,'SQL INJECTION E SECOND ORDER','A injeção de SQL normalmente permite que um invasor extraia todo o banco de dados do site vulnerável, incluindo informações do usuário, senhas criptografadas e dados comerciais. Isso pode levar ao comprometimento em massa de contas de usuários, dados criptografados e mantidos como resgate ou dados roubados vendidos a terceiros.  Vulnerabilidades de injeção de SQL surgem quando dados controláveis pelo usuário são incorporados em consultas SQL de banco de dados de maneira insegura. Um invasor pode fornecer entrada criada para romper o contexto de dados em que sua entrada aparece e interferir na estrutura de uma consulta. Enquanto que a injeção SQL de segunda ordem surge quando os dados fornecidos pelo usuário são armazenados pelo aplicativo e posteriormente incorporados às consultas SQL de maneira insegura. Para detectar a vulnerabilidade, normalmente é necessário enviar dados adequados em um local e, em seguida, usar alguma outra função do aplicativo que processa os dados de maneira insegura.  A ferramenta Checkmarx demonstrou a vulnerabilidade na variável XXX na seguinte parte do código que pode ser observada na aba abaixo.','A prevenção da vulnerabilidade SQL Injection e Second Order envolvem alguns fatores: Não use strings de concatenação dinâmica para construir consultas SQL. Em vez de concatenação de cadeia de caracteres insegura, use componentes de banco de dados seguros, como consultas parametrizadas e associações de objetos (por exemplo, comandos e parâmetros) •	Validar todos os dados não confiáveis, independentemente da fonte •	Uso de whitelist (com os valores que são apenas permitidos) •	Restrinja o acesso aos objetos e funcionalidades do banco de dados, de acordo com o Princípio do Mínimo Privilégio. •	Prefira usar procedimentos armazenados de banco de dados para todos os acessos a dados, em vez de consultas dinâmicas ad-hoc •	A validação de dados pode ser realizada de forma eficaz usando uma biblioteca segura, como as bibliotecas Encoder ou ESAPI do OWASP Aqui temos dois exemplos de como parametrizar a Query. No primeiro exemplo, podemos utilizar o método setParameter() que também previne contra SQL injection:  •	Com parametrização e método setParameter() List<UserBean> users = session.createQuery(‘from UserBean where username = :username’) .setParameter(‘username’, username) .list();  •	Apenas com parametrização x String user = ‘user’; // comes from user String password = ‘password’; // comes from user, gets hashed, etc String query = SELECT * FROM users WHERE user = ? AND password = ?’; PreparedStatement statement = con.prepareStatement(query); myStmt.setString(1, user); myStmt.setString(2, password);','https://portswigger.net/kb/issues/00100200_sql-injection'),(7,'PATH TRAVERSAL (ABSOLUTE E RELATIVE)','A vulnerabilidade Path Traversal surge quando dados controláveis pelo usuário são colocados em um arquivo ou caminho de URL que é usado no servidor para acessar recursos locais, que podem estar dentro ou fora da raiz da aplicação web.  Se vulnerável, um invasor pode modificar o caminho do arquivo para acessar diferentes recursos, que podem conter informações confidenciais no servidor.   A ferramenta Checkmarx demonstrou a vulnerabilidade na variável XXXX na seguinte parte do código que pode ser observada na aba abaixo.','A prevenção da vulnerabilidade Path Traversal envolve alguns fatores: •	Idealmente, evite depender de dados dinâmicos para seleção de arquivos •	Valide todas as entradas, independentemente da fonte. A validação deve ser baseada em uma White  •	Aceite dados dinâmicos apenas para o nome do arquivo, não para o caminho e as pastas •	Certifique-se de que o caminho do arquivo esteja totalmente canonizado •	Limite explicitamente o aplicativo para usar uma pasta designada separada da pasta binária de aplicativos •	Restrinja os privilégios do usuário do sistema operacional do aplicativo aos arquivos e pastas necessários Aqui temos um código de exemplo para evitar que essa vulnerabilidade continue persistindo: File file = new File(BASE_DIRECTORY, userInput);  if (file.getCanonicalPath().startsWith(BASE_DIRECTORY)) {  // process file  }\'','https://portswigger.net/web-security/file-path-traversal'),(8,'CGI','O servidor web remoto hospeda scripts CGI que não conseguem sanitizar adequadamente as strings de solicitação de JavaScript malicioso. Aproveitando esse problema, um invasor pode fazer com que HTML arbitrário e código de script sejam executados no navegador de um usuário dentro do contexto de segurança do site afetado. Esse XSS provavelmente será não persistente ou refletido.','As recomendações são as mesmas demonstradas para o item sobre XSS.','https://portswigger.net/web-security/cross-site-scripting'),(9,'CSRF','A falsificação de solicitação entre sites (também conhecida como CSRF) é uma vulnerabilidade de segurança web que permite que um invasor induza os usuários a realizar ações que não pretendiam realizar.  A ferramenta Checkmarx demonstrou a vulnerabilidade no FORM_TOKEN que pode ser observada na aba abaixo.','A prevenção da vulnerabilidade CSRF envolve uma camada adicional de autenticação que é incorporada ao mecanismo de validação de solicitação. Esse mecanismo anexaria um token adicional que se aplica apenas a um determinado usuário. •	Esse Token estará disponível na página da web do usuário, mas não será anexado automaticamente a uma solicitação de um site diferente (não pode ser armazenado em um cookie) •	Um token CSRF deve ser gerado e exclusivo por usuário por sessão (e, de preferência, por solicitação) •	O token CSRF deve ser inserido no formulário do lado do cliente e enviado ao servidor como parte da solicitação do formulário (pode ser um campo oculto em um formulário HTML) •	Deve ser estritamente validado em todos os casos antes que a ação seja executada   Aqui abaixo temos um exemplo de como podemos utilizar o CSRF em cada tela, garantindo que está autenticado:  public void doPost (HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { 	HttpSession session = request.getSession(); 	String email = request.getParameter(‘NewEmail’);   	String csrfFormToken = request.getParameter(‘csrfToken’);   	String csrfSessionToken = session.getAttribute(‘csrfToken’);     	if (csrfFormToken == null || !csrfFormToken.equals(csrfSessionToken)) { 	       	     } else { 		if (isAuthenticated(session)) { }\'','https://portswigger.net/web-security/csrf'),(10,'FRAMEABLE LOGIN PAGE','A vulnerabilidade Frameable Login Page permite que a configuração das páginas Web dentro de um iframe em uma página Web não confiável deixe essas páginas Web vulneráveis ao Clickjacking. Isso pode permitir que um invasor injete uma página Web vulnerável, definindo-a dentro de um iframe em uma página Web maliciosa.','A prevenção da vulnerabilidade Clickjacking envolve a adição do header X-Frame-Options.  Isso geralmente ocorre no arquivo webSecurity.java  Aqui abaixo, temos um exemplo de implementação:  response.addHeader(‘X-Frame-Options’, ‘DENY’);','https://portswigger.net/web-security/clickjacking'),(11,'HTTP ONLY COOKIES','Os cookies que contêm o identificador de sessão do usuário e outros cookies de aplicativos confidenciais normalmente são acessíveis por scripts do lado do cliente, como JavaScript. Isso não ocorre caso use a flag de cookie httpOnly. Assim, esses cookies não poderão ser lidos e acessados por scripts de cliente mal-intencionados como o XSS.','A prevenção da vulnerabilidade HTTP Only Cookies envolve setar para True a flag httpOnly.  Isso geralmente ocorre no arquivo web.xml  Aqui abaixo podemos ver como implementar no código:  <session-config>         <session-timeout>30</session-timeout>         <cookie-config>             <http-only>true</http-only>             <secure>true</secure>         </cookie-config>     </session-config>','https://docs.spring.io/spring-security/reference/features/exploits/headers.html#headers-custom'),(12,'INPUT PATH NOT CANONICALIZED','O aplicativo usa a entrada do usuário no caminho do arquivo para acessar arquivos no disco local do servidor de aplicativos.  A ferramenta Checkmarx demonstrou a vulnerabilidade no objeto XXXX na seguinte parte do código que pode ser observada na aba abaixo.','As recomendações são as mesmas demonstradas para o item sobre Path Traversal.','https://portswigger.net/web-security/file-path-traversal'),(13,'MISSING HSTS','A falha em definir um cabeçalho HSTS e fornecer um valor razoável de max-age de pelo menos um ano pode deixar os usuários vulneráveis a ataques Man-in-the-Middle. Dessa forma, forçar o HTTPS impedirá qualquer uso futuro de HTTP, o que pode dificultar alguns ataques.','A prevenção da vulnerabilidade HSTS envolve em adicionar o cabeçalho para HSTS.  Isso geralmente ocorre no arquivo web.xml (Em arquivo java)  Aqui abaixo podemos ver como implementar no código: <system.webServer>     <httpProtocol>         <customHeaders>              <add name=‘Strict-Transport-Security’ value=‘max-age=31536000; includeSubDomains’/>          </customHeaders>     </httpProtocol> </system.webServer> Já em node.js, utilizamos no arquivo web-server.js  : var hsts = require(\'hsts\')  app.use(hsts({   maxAge: 31536000,   includeSubDomains: true  }))','https://docs.spring.io/spring-security/reference/features/exploits/headers.html#headers-custom'),(14,'PARAMETER TAMPERING','O aplicativo fornece informações do usuário sem filtrar por ID do usuário. O aplicativo concatena a entrada do usuário diretamente na string de consulta SQL, sem nenhuma filtragem adicional. A aplicação também não realiza nenhuma validação na entrada, nem a restringe a uma lista pré-calculada de valores aceitáveis  A ferramenta Checkmarx demonstrou a vulnerabilidade na variável XXXX na seguinte parte do código que pode ser observada na aba abaixo.','As recomendações são as mesmas demonstradas para o item sobre SQL Injection.','https://portswigger.net/web-security/sql-injection'),(15,'STRUTS INCOMPLETE VALIDATE METHOD DEFINITION','A estrutura do Struts fornece o conjunto de mecanismos do Validator para impor automaticamente a validação configurada em todas as entradas recebidas. Sem usar essa estrutura, o aplicativo pode ficar exposto a outras fraquezas relacionadas à validação de entrada insuficiente. Um invasor pode encontrar uma maneira de contornar qualquer validação manual, e isso pode levar a outros ataques baseados em entrada, como SQL Injection, XSS, expansão de entidade XML e muito mais.  A aplicação concatena a entrada do usuário diretamente na string de consulta SQL, sem nenhuma filtragem adicional. Como também, não realiza nenhuma validação na entrada, nem restringe a uma white list.  A ferramenta Checkmarx demonstrou a vulnerabilidade ao método XXXX na seguinte parte do código que pode ser observada na aba abaixo.','As recomendações são: •	Use os recursos do Struts Validator para impor automaticamente a validação de entrada •	Use as classes Validator corretamente e configure a validação  •	Prefira a validação automática configurada  •	Prefira a validação automática configurando o formulário usando o validation.xml •	Se for implementar a lógica de validação personalizada, substituindo o método default validate(), utilize a função super.validate()  Aqui abaixo podemos ver como implementar no código no arquivo struts-config.xml:  public ActionErrors validate(         ActionMapping mapping,         HttpServletRequest request) {          ActionErrors errors = super.validate(mapping, request); }\'','https://cwe.mitre.org/data/definitions/103.html'),(16,'STRUTS VALIDATION TURNED OFF ','A estrutura do Struts fornece o conjunto de mecanismos do Validator para impor automaticamente a validação configurada em todas as entradas recebidas. Sem usar essa estrutura, o aplicativo pode ficar exposto a outras fraquezas relacionadas à validação de entrada insuficiente. Um invasor pode encontrar uma maneira de contornar qualquer validação manual, e isso pode levar a outros ataques baseados em entrada, como SQL Injection, XSS, expansão de entidade XML e muito mais.  A aplicação concatena a entrada do usuário diretamente na string de consulta SQL, sem nenhuma filtragem adicional. Como também, não realiza nenhuma validação na entrada, nem restringe a uma white list.  A ferramenta Checkmarx demonstrou a vulnerabilidade parâmetro validate setado como False na seguinte parte do código que pode ser observada na aba abaixo.','Certifique-se de que o mapeamento de cada ação de formulário tenha a validação habilitada, definindo validate=‘true’  Aqui abaixo podemos ver como implementar no arquivo struts-config.xml:  <action-mappings>       <action path=‘/custom-action’                type=‘CustomActionValidatorForm’                name=‘customActionValidatorForm’                scope=‘request’               cancellable=‘true’               input=‘input’               validate=‘true’>       </action> </action-mappings>','https://cwe.mitre.org/data/definitions/103.html'),(17,'UNSAFE OBJECT BINDING','A vulnerabilidade Unsafe Object Binding pode expor setters não intencionais a ataques remotos, permitindo que eles acessem diretamente objetos, atributos e até objetos dentro de objetos por meio de setters amplamente vinculados a uma solicitação recebida.  A ferramenta Checkmarx demonstrou a vulnerabilidade na variável XXXX na seguinte parte do código que pode ser observada na aba abaixo.','As recomendações para essa vulnerabilidade consiste em revisar todos os objetos atribuídos em massa para garantir que nenhum construtor ou setter público não intencional seja exposto involuntariamente.  Aqui abaixo podemos ver como implementar no código:  filter.setEquipeIds(idsEquipes);          filter.setPage(autoInfracaoFilterDTO.page);','https://dev.to/wakeupmh/how-to-avoid-insecure-binder-configuration-in-java-2m7d'),(18,'SERVER DOS BY LOOP','Um atacante pode fornecer uma contagem de iteração de loop muito alta, fazendo com que o loop continue por longos períodos, potencialmente fazendo com que a aplicação pare de responder.   A ferramenta Checkmarx demonstrou a vulnerabilidade na variável XXXX na seguinte parte do código que pode ser observada na aba abaixo.','Considere evitar a dependência de inputs do usuário para determinar o número de iterações de um loop.Aqui abaixo podemos ver um exemplo de como implementar no código:  var iterations = req.query.iterations; if (iterations < MAX_ITERATIONS) { 	for (var i = 0 ; i < iterations; i++) { 		// Perform action 	} }\'','https://owasp.org/www-community/attacks/Denial_of_Service'),(19,'OUT-OF-DATE VERSION - BOOTSTRAP','A versão 3.0.1 do Bootstrap possui uma validação não eficiente contra input da aplicação, conforme CVE-2019-8331. O input é o mecanismo de entrada de informação entre o usuário e a interface da aplicação. Dessa forma, caso a aplicação não seja atualizada, é possível que essa vulnerabilidade seja explorada e haja, por exemplo, um ataque de XSS (Cross-Site Scripting), onde uma pessoa má intencionada pode injetar um código malicioso e capturar a sessão do usuário ou mesmo, redirecioná-lo para uma página indevida.   	Evidência da biblioteca vulnerável que pode ser observada na aba abaixo.','Atualizar a instalação do Bootstrap para a última versão assim que possível.','https://security.snyk.io/vuln/SNYK-JS-BOOTSTRAP-173700 '),(20,'OUT-OF-DATE VERSION – JQUERY UI – AUTOCOMPLETE,DIALOG E TOOLTIP','A versão 1.10.3 do JQuery UI possui uma validação não eficiente contra input da aplicação, conforme CVE-2021-41184. O input é o mecanismo de entrada de informação entre o usuário e a interface da aplicação. Dessa forma, caso a aplicação não seja atualizada, é possível que essa vulnerabilidade seja explorada e haja, por exemplo, um ataque de XSS (Cross-Site Scripting), onde uma pessoa má intencionada pode injetar um código malicioso e capturar a sessão do usuário ou mesmo, redirecioná-lo para uma página indevida. Isso pode ocorrer com o JQuery UI contendo métodos como .position()   Podemos observar a manipulação indevida no código abaixo:  <script>          $(function() {             // Position the dialog offscreen to the left, but centered vertically             $( ‘#position1’ ).position({                my: ‘center’,                at: ‘center’,                of: ‘#targetElement’ 		}); 	} </script> 	 	Evidência da biblioteca vulnerável que pode ser observada na aba abaixo.','Atualizar a instalação do JQuery UI para a última versão assim que possível.','https://security.snyk.io/vuln/npm:jquery:20150627'),(21,'OUT-OF-DATE VERSION - JQUERY','A versão 1.10.2 do JQuery possui uma validação não eficiente contra input da aplicação, conforme CVE-2015-9251. O input é o mecanismo de entrada de informação entre o usuário e a interface da aplicação. Dessa forma, caso a aplicação não seja atualizada, é possível que essa vulnerabilidade seja explorada e haja, por exemplo, um ataque de XSS (Cross-Site Scripting), onde uma pessoa má intencionada pode injetar um código malicioso e capturar a sessão do usuário ou mesmo, redirecioná-lo para uma página indevida. Isso pode ocorrer com HTML contendo <option> e JQuery contendo métodos como .html() e .append().   Podemos observar a manipulação indevida no código abaixo:  <script>          $(function() {             // Position the dialog offscreen to the left, but centered vertically             $( ‘#position1’ ).position({                my: ‘center’,                at: ‘center’,                of: ‘#targetElement’ 		}); 	} </script>          	 	Evidência da biblioteca vulnerável que pode ser observada na aba abaixo.','Atualizar a instalação do JQuery para a última versão assim que possível.','https://security.snyk.io/vuln/npm:jquery:20150627'),(22,'DESSERIALIZAÇÃO DE DADO INSEGURO','A desserialização de dado inseguro, também conhecido como desserialização insegura, é uma vulnerabilidade que pode levar à execução remota do código (conhecido como RCE). Além disso, podem ser usadas para realizar ataques de injeção ou mesmo, escalar privilégios no sistema operacional do servidor, onde a aplicação está rodando.  A ferramenta Checkmarx demonstrou a vulnerabilidade na seguinte parte do código XXXX na seguinte parte do código que pode ser observada na aba abaixo.','A prevenção da vulnerabilidade Desserialização Insegura envolve alguns fatores: •	Contrução de Objeto •	Uso de whitelist (com os valores que são apenas permitidos) Para o código vulnerável da aplicação SINS, podemos definir a declaração do objeto:  XStream xstream = new XStream(); Como também adicionar as próprias permissões para criar sua própria whitelist:  xstream.addPermission(NoTypePermission.NONE);  xstream.allowTypes(Collection.class);  xstream.allowTypeHierarchy(Collection.class);','https://owasp.org/www-project-top-ten/2017/A8_2017-Insecure_Deserialization'),(23,'IMPROPER RESTRICTION OF STORED XXE REF','Um aplicativo que analisa e substitui as referências de entidade DTD, em um documento XML que o usuário controla, pode permitir que um invasor crie um documento XML para ler arquivos arbitrários do servidor. Esse documento XML pode conter uma referência de entidade XML. Isso permitiria que uma pessoa má intencionada recuperasse qualquer arquivo de sistema arbitrário no servidor por meio do ataque conhecido como XXE (XML external entity injection).  Na imagem abaixo, temos um exemplo na variável XXXX, identificada pela ferramenta Checkmarx,que pode ser observada na aba abaixo.','Assim, uma pessoa má intencionada pode fazer upload de um documento XML que contém uma declaração DTD, em particular uma definição de entidade que se refere a um arquivo local no disco do servidor, por exemplo, <!ENTITY xxe SYSTEM ‘file:///c:/boot.ini’>. Se o documento XML analisado for retornado ao usuário, o resultado incluirá o conteúdo do arquivo de sistema sensível. Dessa maneira, ele pode executar um código malicioso, como visto no exemplo abaixo, caso a aplicação não possua um mecanismo de defesa:    <?xmlversion=‘1.0’ encoding=‘UTF-8’?> <!DOCTYPE example [    <!ENTITY file SYSTEM ‘file:////etc/shadow‘ >  ]>  <example>&file;</example>','https://portswigger.net/web-security/xxe'),(24,'SSRF','A vulnerabilidade SSRF (server-side request forgery) é uma vulnerabilidade de segurança Web que permite que uma pessoa má intencionada induza a aplicação, do lado do servidor, a fazer solicitações de maneira não intencional. Um ataque SSRF bem-sucedido pode resultar em ações não autorizadas ou acesso a dados dentro da organização, seja no próprio aplicativo vulnerável ou em outros sistemas de back-end com os quais o aplicativo possa se comunicar. Em algumas situações, a vulnerabilidade SSRF pode permitir que uma pessoa má intencionada execute comandos arbitrários. Por exemplo, no exemplo de código abaixo, um aplicativo de compras permite o usuário visualizar informações administrativas em uma determinada loja:  POST /product/stock HTTP/1.0 Content-Type: application/x-www-form-urlencoded Content-Length: 118  stockApi=http://localhost/admin A ferramenta Checkmarx demonstrou a vulnerabilidade na seguinte parte do código que pode ser observada na aba abaixo.','A prevenção da vulnerabilidade SSRF envolve alguns fatores: •	Não se conecte a serviços arbitrários com base na entrada do usuário •	Se possível, o aplicativo deve fazer com que o navegador do usuário recupere as informações desejadas diretamente •	Se for necessário que o aplicativo faça proxy da solicitação no servidor, inclua explicitamente na White List, as URLs de destino permitidos e não inclua informações confidenciais do servidor Como também, aqui podemos analisar um exemplo de como validar e redirecionar o usuário do navegador:  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {   if (request.getParameterMap().containsKey(‘url’)) {     String url = request.getParameter(‘url’);     if (url.startsWith(‘/’) && !url.startsWith(‘//’)) {       response.sendRedirect(url);     } else {       response.sendRedirect(‘/’);     }   } }\'','https://portswigger.net/web-security/ssrf'),(25,'UNVALIDATED FORWARDS','A vulnerabilidade Unvalidated Forwars ocorre quando uma aplicação Web aceita a entrada (input) não confiável que pode fazer com que a aplicação redirecione a solicitação para uma URL contida em um input não confiável. Ao modificar a entrada de URL não confiável para um site malicioso, uma pessoa má intencionada pode iniciar com êxito um golpe de phishing e roubar as credenciais do usuário.  A ferramenta Checkmarx demonstrou a vulnerabilidade na seguinte parte do código que pode ser observada na aba abaixo.','A prevenção da vulnerabilidade Unvalidated Forward envolve alguns fatores: •	Se for necessário utilizar, não baseie o destino na entrada do usuário. Sempre valide o input •	Se o input do usuário for necessário para calcular o encaminhamento da URL, receba o código com a URL, em vez do próprio nome do método, e mapeie esse código no servidor com a URL  •	Se for necessário permitir que o usuário forneça um nome do método arbitrário, verifique se o valor fornecido é válido e se o usuário está autorizado a invocar esse método. •	De qualquer forma, não encaminhe a execução do servidor para um destino com base na entrada do usuário  Como também adicionar função sendRedirect, conforme código abaixo:  response.sendRedirect(‘http://www.mysite.com’);','https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html'),(26,'CLIENT STATE SAVING METHOD JSF','A vulnerabilidade Client State Saving Method JSF ocorre quando valores de ViewState, variáveis e objetos serializados são processados pelo servidor. Dependendo da implementação e uso deste ViewState, isso pode levar a desvios de validação, atividade não autorizada, ataques de script entre sites, vazamentos de informações confidenciais ou execução remota de código.  A ferramenta Checkmarx demonstrou a vulnerabilidade na seguinte parte do código que pode ser observada na aba abaixo.','A prevenção da vulnerabilidade Client State Saving Method JSF envolve utilizar o parâmetro <param-value> como true.  Aqui abaixo podemos ver como implementar no código:  <contextparam>     <paramname>org.apache.myfaces.USE_ENCRYPTION</paramname>     <paramvalue>true</paramvalue> </contextparam>','https://stackoverflow.com/questions/8471551/what-is-state-saving-method-parameter-in-jsf-2-0'),(27,'DEFAULT DEFINER RIGHTS IN PACKAGE OR OBJECT DEFINITION','Gerencie com muito cuidado a configuração, gerenciamento e manuseio de privilégios. Gerencie explicitamente zonas de confiança no software.  A ferramenta Checkmarx demonstrou a vulnerabilidade na seguinte parte do código na aba abaixo.','A prevenção da vulnerabilidade pode ocorrer ao definir qual usuário que pode ter acesso a execução dessa procedure ou garantir que apenas a aplicação tem acesso a execução da procedure.  Aqui abaixo podemos ver como implementar no código:  createorreplace proceduresample_procedure authid current_userasbegin...  casewhenv_risk=\'RISK\'then\'Y\'else\'N\'    GRANT role_listto user_listWITH DELEGATE OPTION;','https://www.sqlinjection.net/defense/pl-sql/'),(28,'STACK TRACE DISCLOSURE','O manuseio inadequado de erros, como a visualização do Stack Trace, pode introduzir uma variedade de problemas de segurança. O problema mais comum é quando mensagens de erro internas detalhadas, como dumps de banco de dados e códigos de erro são exibidos para o usuário.  Essas mensagens revelam detalhes de implementação que não devem ser revelados. Tais detalhes podem fornecer a pessoas má intencionadas pistas importantes sobre possíveis falhas no site.  Podemos observar a manipulação indevida na aplicação nas imagens da aba abaixo.','Retirar endpoints que demonstrem informações indevidas na aplicação, criar página com mensagem de erro padrão ou realizar tratativas no código utilizando Try Catch, para capturar a exceção e não demonstrar para o usuário final.','https://owasp.org/Top10/A05_2021-Security_Misconfiguration/  https://owasp.org/www-community/Improper_Error_Handling '),(29,'OUT OF DATE – VERSION TOMCAT','A versão 9.0.20 do Tomcat até a versão 10.0.2 não validam propriamente o pacote proveniente do TLS. Isso pode levar a um ataque de negação de serviço (DoS). Assim, a aplicação poderia parar de funcionar.   Podemos observar a versão do Tomcat na aba abaixo.','Atualizar a instalação do Tomcat para a última versão assim que possível.','https://www.cvedetails.com/product/887/Apache-Tomcat.html?vendor_id=45'),(30,'SECOND ORDER SQL INJECTION – PL SQL','A injeção de SQL normalmente permite que um invasor extraia todo o banco de dados do site vulnerável, incluindo informações do usuário, senhas criptografadas e dados comerciais. Isso pode levar ao comprometimento em massa de contas de usuários, dados criptografados e mantidos como resgate ou dados roubados vendidos a terceiros.  Vulnerabilidades de injeção de SQL surgem quando dados controláveis pelo usuário são incorporados em consultas SQL de banco de dados de maneira insegura. Um invasor pode fornecer entrada criada para romper o contexto de dados em que sua entrada aparece e interferir na estrutura de uma consulta. Enquanto que a injeção SQL de segunda ordem surge quando os dados fornecidos pelo usuário são armazenados pelo aplicativo e posteriormente incorporados às consultas SQL de maneira insegura. Para detectar a vulnerabilidade, normalmente é necessário enviar dados adequados em um local e, em seguida, usar alguma outra função do aplicativo que processa os dados de maneira insegura.  A ferramenta Checkmarx demonstrou a vulnerabilidade na variável XXXX na seguinte parte do código que pode ser observada na aba abaixo.','A prevenção da vulnerabilidade SQL Injection e Second Order envolvem alguns fatores: •	Não use strings de concatenação dinâmica para construir consultas SQL. Em vez de concatenação de cadeia de caracteres insegura, use componentes de banco de dados seguros, como consultas parametrizadas e associações de objetos (por exemplo, comandos e parâmetros) •	Validar todos os dados não confiáveis, independentemente da fonte •	Uso de whitelist (com os valores que são apenas permitidos) •	Restrinja o acesso aos objetos e funcionalidades do banco de dados, de acordo com o Princípio do Mínimo Privilégio. •	Prefira usar procedimentos armazenados de banco de dados para todos os acessos a dados, em vez de consultas dinâmicas ad-hoc •	A validação de dados pode ser realizada de forma eficaz usando uma biblioteca segura, como as bibliotecas Encoder ou ESAPI do OWASP A prevenção da vulnerabilidade SQL Injection e Second Order envolvem alguns fatores: •	Não use strings de concatenação dinâmica para construir consultas SQL. Em vez de concatenação de cadeia de caracteres insegura, use componentes de banco de dados seguros, como consultas parametrizadas e associações de objetos (por exemplo, comandos e parâmetros) •	Validar todos os dados não confiáveis, independentemente da fonte •	Uso de whitelist (com os valores que são apenas permitidos) •	Restrinja o acesso aos objetos e funcionalidades do banco de dados, de acordo com o Princípio do Mínimo Privilégio. •	Prefira usar procedimentos armazenados de banco de dados para todos os acessos a dados, em vez de consultas dinâmicas ad-hoc •	A validação de dados pode ser realizada de forma eficaz usando uma biblioteca segura, como as bibliotecas Encoder ou ESAPI do OWASP Aqui temos um exemplo de como parametrizar a Query PL/SQL. No primeiro exemplo, podemos utilizar o método setParameter() que também previne contra SQL injection:  •	Com parametrização : BIND VARIABLES WITH EXECUTE IMMEDIATE. CREATE OR REPLACE PROCEDURE testBind(vname IN VARCHAR2) AS BEGIN    EXECUTE IMMEDIATE UPDATE products set price = price-1 where name = :1  USING vname; COMMIT; END;','https://www.sqlinjection.net/defense/pl-sql/'),(31,'SECURITY MISCONFIGURATION','O manuseio inadequado de erros pode introduzir uma variedade de problemas de segurança. O problema mais comum é quando mensagens de erro internas detalhadas, como dumps de banco de dados e códigos de erro são exibidos para o usuário.  Essas mensagens revelam detalhes de implementação que não devem ser revelados. Tais detalhes podem fornecer a pessoas má intencionadas pistas importantes sobre possíveis falhas. Como também, recursos desnecessários são ativados ou instalados (por exemplo, portas, serviços, páginas, contas ou privilégios desnecessários) site. Além disso, recursos desnecessários são ativados ou instalados (por exemplo, portas, serviços, páginas, contas ou privilégios desnecessários), que podem ajudar na identificação da aplicaçao e permitir uma futura exploração   Podemos observar a configuração indevida na aplicação na imagem da aba abaixo, onde foi possível identificar os diretórios através de uma lista de fuzzing comumente utilizada para testes no servidor Tomcat.','Remover configurações que não estão sendo utilizadas, criar página com mensagem de erro padrão ou realizar tratativas no código utilizando Try Catch, para capturar a exceção e não demonstrar para o usuário final.','https://owasp.org/www-community/Improper_Error_Handling  https://owasp.org/Top10/A05_2021-Security_Misconfiguration/ '),(32,'JBOSS RICHFACES RCE','Descrição: Essa vulnerabilidade permite injetar código arbitrário no código Java e executar código remotamente (RCE) em qualquer versão de RichFaces menor que 4.5 (CVE 2015-0279) . Dessa maneira, isso permite que um usuário, não autenticado consiga acessar informações do servidor.   Atualmente, também existem exploits que podem facilmente explorar esse componente. Eles estão contidos em um framework conhecido como Richsploit e podem explorar qualquer versão do RichFaces.','Não existe uma versão do Richfaces que não esteja vulnerável. Essa biblioteca de UI utilizada pelo JSF (JavaServer Faces) não está recebendo nenhum tipo de atualização desde 2016. Dessa forma, torna-se bastante inseguro manter a utilização dessa aplicação, pois como ele não possui mais nenhuma atualização, outras possíveis vulnerabilidades e técnicas ainda mais fáceis de exploração possam surgir.  Além disso, a migração desse componente não é simples, caso se utilize um Framework moderno baseado em JavaScript (como Vuejs ou React, por exemplo) . Assim, o aplicativo precisa ser reescrito do modelo do lado do servidor JSF para o modelo do lado do cliente JavaScript. Isso significa que a interface do usuário deve ser reescrita completamente ou uma grande parte dela. Os endpoints REST precisam ser inseridos entre os serviços e a interface do usuário. Portanto, somente as funções de negócios podem ser preservadas da migração. ','https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-0279   	http://www.mastertheboss.com/web/richfaces/how-to-migrate-richfaces-web-applications-to-another-web-ui/ '),(33,'SESSÃO ID EM URL','A vulnerabilidade de sessão exposta em URL pode fazer com que uma pessoa má intencionada consiga rastrear informações sobre o usuário ou mesmo capturar a sessão do mesmo','Remover a sessão da URL e adicioná-lo em um lugar mais seguro, como cookies de sessão.','https://owasp.org/www-community/attacks/Session_fixation'),(34,'INSECURE TRANSPORTATION SECURITY PROTOCOL SUPPORTED','Os invasores podem realizar ataques man-in-the-middle e observar o tráfego de criptografia entre seu site e seus visitantes.','Recomendamos desabilitar o SSLv3 e substituí-lo por TLS 1.2 ou superior.','https://owasp.org/www-community/vulnerabilities/Insecure_Transport'),(35,'OUT-OF-DATE VERSION - HIGHCHARTS','A versão 5.0.12 do HighCharts possui uma validação não eficiente contra a tag <a> da aplicação, conforme CVE-2018-20801. Dessa forma, caso a aplicação não seja atualizada, é possível que essa vulnerabilidade seja explorada e haja, por exemplo, um ataque de XSS (Cross-Site Scripting), onde uma pessoa má intencionada pode injetar um código malicioso e capturar a sessão do usuário ou mesmo, redirecioná-lo para uma página indevida. Isso pode ocorrer onde a tag para formatos de texto é traduzida em um tspan com onclick, permitindo a injeção de script.  Evidência da biblioteca vulnerável que pode ser observada na aba abaixo.','Atualizar a instalação do HighCharts para a última versão assim que possível.','https://security.snyk.io/vuln/SNYK-JS-BOOTSTRAP-173700  https://snyk.io/vuln/SNYK-JS-HIGHCHARTS-571995'),(36,'OUT-OF-DATE VERSION - ANGULARJS','A versão 1.2.16 do AngularJS possui uma validação não eficiente contra input da aplicação, conforme CVE-2019-14862. No AngularJS antes de 1.7.9 a função `merge()` podia ser induzida a adicionar ou modificar propriedades de `Object.prototype` usando um payload `__proto__`. 	 Evidência da biblioteca vulnerável que pode ser observada na aba abaixo.','Atualizar a instalação do AngularJS para a última versão assim que possível.','https://security.snyk.io/vuln/SNYK-JS-ANGULAR-534884 '),(37,'FILTERING SENSITIVE LOGS','As informações gravadas em arquivos de log podem ser de natureza confidencial e fornecer orientações valiosas a um invasor ou expor informações confidenciais do usuário.','Considere seriamente a confidencialidade das informações gravadas em arquivos de log. Não escreva senhas nos arquivos de log.','https://cwe.mitre.org/data/definitions/532.html'),(38,'OUT-OFDATE VERSION - Nginx','A versão 1.15.6 do Nginx possui diversas vulnerabilidades altas. Entre elas, permite que um invasor seja capaz de forjar pacotes UDP do servidor DNS para causar uma sobrescrita da memória de 1 byte, resultando em falha no processo. ','Atualize o Nginx para a versão mais recente possível','https://nvd.nist.gov/vuln/detail/CVE-2021-23017'),(39,'DANGEROUS FILE UPLOAD','A aplicação permite que os usuários carreguem um arquivo para a aplicação, que é salva em um arquivo dentro do diretório do site. A aplicação não aplica verificações de validação completas no arquivo carregado, especialmente no que diz respeito ao tipo ou conteúdo do arquivo. Isso permite que o invasor carregue arquivos executáveis, em particular o código do servidor da Web, como arquivos .ASP, .PHP e .JSP e outros. Isso pode ser visto no código na aba abaixo.Isso pode ser visto no código da aba abaixo.','Armazenamento: Se possível, evite salvar arquivos carregados em disco no servidor, em vez disso, armazene-os em um armazenamento de dados externo, por exemplo, banco de dados ou sistema de gerenciamento de documentos.\r\nLocalização: Os arquivos do usuário devem ser armazenados em um diretório isolado, fora do diretório do site com a navegação direta desabilitada. Quando necessário, o aplicativo deve ler explicitamente o arquivo no código e transmitir o conteúdo para o usuário de forma aplicativo.\r\nValidação: Sempre valide todas as entradas do usuário. Em particular, imponha uma lista de permissões de tipos de arquivos permitidos, de acordo com a extensão do arquivo e ou tipo MIME. Não permita arquivos arbitrários (como .ASP, .PHP, .JSP, .EXE, .HTML e assim por diante). Por exemplo, aceite apenas imagens como .GIF, .JPG, .PNG, .BMP e assim por diante.     Renomeação: Explicitamente impõe uma extensão pré-definida de acordo com o tipo de arquivo, antes de salvar o arquivo em disco. Pode ser uma extensão codificada ou uma lista configurada de tipos de arquivos permitidos.     \r\nPrivilégios: Como medida de Defesa em Profundidade, configure o servidor de aplicativos para ser executado em uma conta de sistema limitada, com privilégios mínimos de SO.  \r\nRecomendações Específicas:     \r\nValidação: valide o nome do arquivo carregado antes de salvar o arquivo no disco e verifique se o tamanho total do arquivo não excede os limites definidos. \r\nfileExt = Path.GetExtension(path);  \r\nif (fileExt == .jpg || fileExt == .png)      {                 fileUpload.SaveAs(path);      return true;      }\'\r\n','https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload'),(40,'CLIENT DOM COOKIE POISONING','A aplicação não impede que entradas maliciosas sejam inseridas nos cookies da aplicação. Um invasor pode influenciar o navegador da vítima com parâmetros de URL maliciosos, fazendo com que o script carregue esses valores maliciosos no cookie do usuário. Isso pode ser via phishing, links armazenados, links externos e muito mais.Isso pode ser visto no código da aba abaixo.','Não defina cookies utilizando fragmentos da URL, parâmetros GET ou input.\r\n\r\nfunction setCookie()\r\n{\r\n    var value = window.location.hash;\r\n    \r\n    if (actionsArray[value] != undefined)\r\n    {\r\n        var date = new Date();\r\n        date.setTime(date.getTime() + 1000*60*20);\r\n\r\n       document.cookie = \'ActionID=\' + actionsArray[value] + \'; expires=\' + date.toUTCString() + \'; path=/myApp/\' + \'; secure;\' \r\n    }\r\n}','https://owasp.org/www-community/attacks/Session_hijacking_attack'),(41,'VALUE SHADOWING','O Value Shadowing ocorre quando um determinado conjunto de informações pode ser pesquisado e pode conter valores de mesmo nome, cuja precedência um sobre o outro não é imediatamente clara.  Por exemplo, em .NET, um objeto Request pode ser pesquisado por meio de um índice (Request[param]) - no entanto, o valor cuja chave é \"param\" nesta implementação pode ser um parâmetro de query string, um parâmetro de formulário, um cabeçalho, uma variável de servidor e muito mais. Isso faz com que o valor de Request[\"value\"] seja ambíguo, o que pode ser aproveitado para contornar restrições lógicas, medidas de segurança e verificações de valor.Isso pode ser visto no código da aba abaixo.','Sempre se refira explicitamente ao contexto de dados exato do qual os valores são recuperados. Exemplo: referer = Request.UrlReferrer != null ? Request.UrlReferrer.ToString() : \"None\" ; if (TRUSTED_DOMAIN.startswith(referer)) {   // Do something }\'','https://vulncat.fortify.com/en/detail?id=desc.semantic.dotnet.value_shadowing_server_variable'),(42,'PRIVACY VIOLENTION ','O aplicativo envia informações do usuário, como senhas, informações de conta ou números de cartão de crédito, para fora do aplicativo, como gravá-las em um texto local ou arquivo de log ou enviá-las para um serviço da Web externo.Isso pode ser visto no código da aba abaixo.','Os dados pessoais devem ser removidos antes de gravar em logs ou outros arquivos.     Revise a necessidade e justificativa de envio de dados pessoais para web services remotos. ','https://vulncat.fortify.com/en/detail?id=desc.dataflow.java.privacy_violation'),(43,'PERSISTENT CONNECTION STRING','Definir Persist Security Info como TRUE permite que informações de segurança, como nome de usuário e senha, sejam obtidas de uma conexão assim que ela for estabelecida.  Defini-lo como False garantirá que as informações de segurança sejam descartadas após serem usadas para criar a conexão, reduzindo sua exposição.Isso pode ser visto no código da aba abaixo.','Defina explicitamente Persist Security Info como False ou deixe-o em seu valor padrão.     Se Persist Security Info precisar ser True (por exemplo, para fins de desenvolvimento), é vital remover esse sinalizador ou defini-lo como False depois que não for mais necessário. ','https://learn.microsoft.com/en-us/dotnet/framework/data/adonet/protecting-connection-information'),(44,'MISSING COLUMN ENCRYPTION ','As colunas do banco de dados são armazenadas em texto simples, o que significa que seria muito fácil ler os dados se alguém tivesse acesso ao servidor de banco de dados.Isso pode ser visto no código da aba abaixo.','O DBMS pode suportar criptografianativa e esse recurso deve ser utilizado.\r\nExemplo: \r\nstring connectionString = \'Data Source=server63; Initial Catalog=Clinic; Integrated Security=true; Column Encryption Setting=enabled\'; SqlConnection connection = new SqlConnection(connectionString);','https://owasp.org/Top10/A02_2021-Cryptographic_Failures/'),(45,'ELMAH ENABLED','ELMAH (Error Logging Modules and Handlers) é um serviço que registra erros e comportamento do usuário no aplicativo. Destina-se apenas ao uso de teste de log interno; a falha em remover ou restringir o acesso remoto ao ELMAH em um ambiente de produção exporia as informações de solicitação ao vivo.  As informações retidas pelas informações do ELMAH incluem cabeçalhos de solicitação, conteúdo de solicitação e informações do servidor. Quando configurado para ser exposto, navegar para elmah.axd no contexto do aplicativo permitirá que invasores não autenticados recuperem essas informações.Isso pode ser visto no código da aba abaixo.','Desative todo e qualquer recurso de log acessível pela Web ao implantar um aplicativo em um ambiente de produção.     Certifique-se sempre de que o acesso a essas instalações, mesmo durante a preparação, seja o mais limitado possível para evitar vazamentos de informações.     Se for necessário ter o ELMAH em um ambiente de produção, bloqueie o acesso remoto ao ELMAH ou aplique requisitos estritos de autenticação e autorização para evitar acesso anônimo ou sem privilégios','https://www.acunetix.com/vulnerabilities/web/elmah-axd-information-disclosure/'),(46,'INSUFICIENT CONNECTION STRING ENCRIPTION','O uso de uma conexão não criptografada na rede para se conectar a um banco de dados exporá as credenciais.Isso pode ser visto no código da aba abaixo.','Sempre use uma conexão de banco de dados criptografada, de preferência com um certificado fornecido por uma autoridade de certificação.     Se não houver um certificado provisionado de uma autoridade de certificação conhecida, um certificado autoassinado também será possível. Exemplo: string connectionString = \'Data Source=server63; Initial Catalog=Clinic; Integrated Security=true; Column Encryption Setting=enabled; Encrypt=true; TrustServerCertificate=true\'; SqlConnection connection = new SqlConnection(connectionString);','https://learn.microsoft.com/en-us/dotnet/framework/data/adonet/protecting-connection-information'),(47,'REQUIRESSL','A estrutura de aplicativo da web por padrão não define o sinalizador seguro para o cookie sessionID do aplicativo e outros cookies de aplicativo confidenciais. Da mesma forma, o aplicativo não usa explicitamente o sinalizador de cookie seguro, permitindo que eles sejam enviados em texto simples em uma sessão insegura.Isso pode ser visto no código da aba abaixo.','Sempre defina o sinalizador seguro para quaisquer cookies confidenciais do lado do servidor. Se o aplicativo manipular explicitamente os cookies diretamente no código do aplicativo, defina o sinalizador seguro para cookies confidenciais definidos pelo aplicativo. Configure o aplicativo para sempre usar cookies seguros, no arquivo de configuração de todo o site. Ative o sinalizador Seguro ou use a API Set-Secure relevante no código. Exemplo no arquivo Web.config: <system.web>  <httpCookies requireSSL=\'true\' ></httpCookies> </system.web>','https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography/01-Testing_for_Weak_SSL_TLS_Ciphers_Insufficient_Transport_Layer_Protection'),(48,'CLIENT CODE INJECTION','O aplicativo cria páginas da Web que incluem dados não confiáveis, seja no input, do banco de dados do aplicativo ou de outras fontes externas.Os dados são usados diretamente no HTML da página.Isso pode ser visto no código da aba abaixo.','Codifique totalmente todos os dados dinâmicos, independentemente da fonte, antes de incorporá-los na saída. A codificação deve ser sensível ao contexto. Por exemplo:      Codificação HTML para conteúdo HTML     Codificação de atributo HTML para saída de dados para valores de atributo     Codificação JavaScript para JavaScript gerado pelo servidor. Exemplo: <div id=divElem ></div>  <script> var divElemText = document.getElementById(\'divElem\').innerText;  trustedFunction(divElemText); </script>','https://owasp.org/www-community/attacks/Code_Injection'),(49,' CLIENT HTML5 STORE SENSITIVE DATA WEB IN STORAGE','A aplicação armazena dados, que podem conter PII (Informações Pessoais Identificáveis), no navegador ou dispositivo do cliente. O aplicativo usa formas inseguras de armazenamento, que não fornecem inerentemente nenhuma proteção contra acesso não autorizado. Esses dados não são criptografados ou higienizados antes de serem armazenados, portanto, uma entidade maliciosa com acesso ao dispositivo ou navegador pode facilmente recuperar os dados do usuário.Isso pode ser visto no código da aba abaixo no método setItem().','Evite armazenar dados confidenciais, como PII, em clientes desprotegidos. Se PII ou outros dados confidenciais precisarem ser armazenados no cliente, certifique-se de que estejam criptografados ou protegidos de outra forma. Exemplo: var globalAccountId;   function storeUserData() {  	var accountId = getUserAccount(); 	globalAccountId = accountId; // Data is stored in DOM, but not persistently }\'','https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html'),(50,'OUT OF DATE VERSION - MOMENT JS','Moment.js é uma biblioteca de datas JavaScript para analisar, validar, manipular e formatar datas. Uma vulnerabilidade de passagem de caminho afeta usuários npm (servidor) de Moment.js entre as versões 1.0.1 e 2.29.1, especialmente se uma string de localidade fornecida pelo usuário for usada diretamente para alternar a localidade momentânea. Esse problema foi corrigido no 2.29.2 e o patch pode ser aplicado a todas as versões afetadas. Como solução alternativa, limpe o nome de localidade fornecido pelo usuário antes de passá-lo para Moment.js.','Atualizar a instalação do MomentJs para a última versão assim que possível.','https://nvd.nist.gov/vuln/detail/CVE-2022-24785'),(51,'OUT OF DATE VERSION - ASP.NET','A vulnerabilidade de script entre sites (XSS) em System.Web.Mvc.dll no Microsoft ASP.NET Model View Controller (MVC) 2.0 a 5.1 permite que invasores remotos injetem scripts da Web arbitrários ou HTML por meio de uma página da Web criada, também conhecida como MVC XSS Vulnerabilidade.','Atualizar a instalação do ASP.NET para a última versão assim que possível.','https://nvd.nist.gov/vuln/detail/CVE-2014-4075'),(52,'SESSION COOKIE NOT MARKED AS SECURE','Isso significa que o cookie pode ser roubado por um invasor que pode interceptar o tráfego com sucesso, após um ataque man-in-the-middle bem-sucedido.','Setar cookie como secure, conforme exemplo: app.config[\'SESSION_COOKIE_SECURE \'] = True','https://owasp.org/www-community/controls/SecureCookieAttribute');
/*!40000 ALTER TABLE `report` ENABLE KEYS */;
UNLOCK TABLES;
